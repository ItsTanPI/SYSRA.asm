<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSRA.asm</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://js-dos.com/cdn/js-dos.js"></script>
    <link rel="stylesheet" href="https://js-dos.com/cdn/js-dos.css">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        #dos {
            width: 100%;
            height: 100%;
        }

        .aspect-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    
    width: 100vw;
    height: calc(100vw * (200 / 320)); 

    max-height: 100vh;
    max-width: calc(100vh * (320 / 200)); 
        
    background: rgba(1, 1, 1, 1); 
    pointer-events: none; 
}

.hidediv
{
    visibility: hidden;
}
    </style>
    <link rel="stylesheet" href="https://v8.js-dos.com/latest/js-dos.css">
    <script src="https://v8.js-dos.com/latest/js-dos.js"></script>
</head>
<body style="background-color: black;">

    <div id="dos" ></div>
    <div id="we"></div>
    

    <script>
        Dos(document.getElementById("dos"), {url:"SYSRA.zip"})
    </script>

<script>
    let dosPlayer;
    var dosCanvas;

    function waitForCanvas(callback) {
    let checkInterval = setInterval(() => {
        let canvas = document.querySelector("canvas"); 
        if (canvas) {
            console.log("Canvas found:", canvas);
            dosCanvas = canvas
            clearInterval(checkInterval); 
            callback(canvas); 
        }
    }, 100); 
}
function startApp(canvas) {
    console.log("DOS Canvas:", canvas);

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
    camera.position.z = 1;

    
    const myDiv = document.getElementById("dos"); 
    myDiv.classList.add("hidediv"); 
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    var gh = document.getElementById("we")
    gh.classList.add("aspect-overlay"); 
    renderer.setSize(gh.clientWidth, gh.clientHeight);
    gh.appendChild(renderer.domElement);

    
    const geometry = new THREE.PlaneGeometry(2, 2);
    let texture = new THREE.CanvasTexture(canvas); 
    texture.needsUpdate = true;
    
    const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: {
        sceneTexture: { value: texture },  
        iResolution: { value: new THREE.Vector2(gh.clientWidth, gh.clientHeight) },
        bloomIntensity: { value: 1.5 },
        time: { value: 0.0 }  // Add time uniform
    },
    vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
    fragmentShader: `
    uniform sampler2D sceneTexture;
    uniform vec2 iResolution;
    uniform float bloomIntensity;
    uniform float time;  // Add time for animated noise

    #define CURVATURE 5.0
    #define BLUR 0.01
    #define CA_AMT 1.0055

    // Random noise function
    float random(vec2 uv) {
    uv = mod(uv, 100.0); // Keeps values small to avoid precision loss
    return fract(sin(dot(uv, vec2(127.1, 311.7))) * 43758.5453123);
}

    // Noise function with time-based variation
    float noise(vec2 uv) {
        uv *= iResolution.xy; // Scale to screen resolution
        return random(uv + time * 0.5); // Animated noise
    }

    void main() {
        vec2 fragCoord = gl_FragCoord.xy;
        vec2 uv = fragCoord / iResolution.xy;

        // Curving effect
        vec2 crtUV = uv * 2.0 - 1.0;
        vec2 offset = crtUV.yx / CURVATURE;
        crtUV += crtUV * offset * offset;
        crtUV = crtUV * 0.5 + 0.5;

        vec2 edge = smoothstep(0.0, BLUR, crtUV) * (1.0 - smoothstep(1.0 - BLUR, 1.0, crtUV));

        // Chromatic aberration
        vec3 color;
        color.r = texture2D(sceneTexture, (crtUV - 0.5) * CA_AMT + 0.5).r;
        color.g = texture2D(sceneTexture, crtUV).g;
        color.b = texture2D(sceneTexture, (crtUV - 0.5) / CA_AMT + 0.5).b;
        
        float staticNoise = noise(uv) * 0.115; // 0.3 = Strength of noise
        color += vec3(staticNoise);
        color *= edge.x * edge.y;

        // --- NOISE EFFECT ---

        // Scanline effect
        if (mod(fragCoord.y, 2.0) < 1.0) color *= 0.7;
        else if (mod(fragCoord.x, 3.0) < 1.0) color *= 0.7;
        else color *= 1.2;

        gl_FragColor = vec4(color, 1.0);
    }
`
});


    const mesh = new THREE.Mesh(geometry, shaderMaterial);
    scene.add(mesh);

    function animate() 
    {
    shaderMaterial.uniforms.time.value += 0.1;  // Increment time
    }


    function captureCanvas() {
        if (canvas && canvas.width > 0 && canvas.height > 0) {
            texture.dispose(); 
            animate();
            texture = new THREE.CanvasTexture(canvas); 
            //texture.magFilter = THREE.NearestFilter;
            //texture.minFilter = THREE.NearestFilter;
            shaderMaterial.uniforms.sceneTexture.value = texture;
            
        }
    }

    function render() {
        captureCanvas();
        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }

    window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        shaderMaterial.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
    });

    render();
}


    waitForCanvas(startApp);
</script>

</body>
</html>
